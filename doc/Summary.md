## Summary

JetBrains MPS is an open‐source language workbench designed for creating and using domain-specific languages (DSLs) through a unique projectional editing approach. Instead of relying on traditional text parsing, MPS stores code directly as an abstract syntax tree (AST), allowing developers to mix textual, graphical, and tabular notations seamlessly. This method eliminates grammatical ambiguities and supports the flexible composition and reuse of language components.

Key features include the ability to define custom languages by setting up abstract syntax, editor projections, type systems, and constraints. MPS enables direct manipulation of the AST with multiple notations and provides built-in code generation, which translates high-level DSL code into lower-level executable code in languages like Java or C. The integrated development environment mirrors modern IDE functionalities such as code completion, refactoring, and debugging, making it a comprehensive tool for language-oriented programming.

Originating from early 2000s research at JetBrains and inspired by the Language-Oriented Programming paradigm, MPS evolved from an experimental prototype into a production-ready platform. Public beta versions appeared around 2007–2008, with a stable version launched in 2009 under an open-source license. Its maturity has fostered adoption in diverse fields—ranging from embedded systems and enterprise applications to complex business logic and academic research—demonstrating its practical impact on both industry and education.

Overall, JetBrains MPS has redefined software development by empowering developers and domain experts to tailor languages specifically to their problems, thereby enhancing productivity and precision in crafting complex systems.


## Technical Overview and Features

**JetBrains MPS (Meta Programming System)** is an open-source **language workbench** for designing and implementing domain-specific languages (DSLs) and their development environments. 

Unlike traditional programming IDEs that rely on parsing text, MPS uses a **projectional editor**: code is stored directly as an abstract syntax tree (AST) and edited through custom notations rather than raw text. This approach eliminates the need for a parser and avoids grammatical ambiguities, allowing syntax that can mix textual and graphical elements (for example, tables, mathematical symbols, or diagrams embedded in code). In essence, developers using MPS manipulate the program’s AST through a structured editor, which _“looks like text and in many aspects behaves like text”_ but never requires parsing back and forth. This gives MPS a unique ability to support notations and language compositions that would be impractical in a traditional text-based IDE.

**Key features** of MPS include:

-   **Custom Language Definition** – Users can define new languages or extend existing ones by specifying language structure (abstract syntax), editor appearance (concrete syntax projection), type systems, constraints, and other semantics. MPS provides an integrated set of tools to create these language aspects and enforces rules (like type checking) during editing.
-   **Projectional Editing** – As noted, MPS’s editor allows editing the AST directly. This supports **multiple notations** (textual, tabular, graphical, form-based, etc.) within one environment. Developers can freely combine DSLs without worrying about parser conflicts – any composition of languages is syntactically valid by construction.
-   **Language Composition and Reuse** – Languages in MPS are inherently **composable** and modular. One DSL can be embedded in or extended by another, and multiple extensions can coexist in the same code without ambiguity. This enables reuse of language components across projects (e.g. adding a units-of-measure DSL into a base language) without grammar clashes.
-   **Code Generation (Generators)** – MPS follows a **generative approach**: high-level DSL code is translated into lower-level code (often in general-purpose languages like Java, C, XML, etc.) for execution. The language designer defines _generator_ rules that transform the AST of the DSL into target language code. This allows domain experts to work at a higher abstraction level, while MPS produces the executable implementation.
-   **Integrated Development Environment** – MPS is not only a language design tool but also an IDE for using the created languages. It provides editing support akin to modern IDEs (code completion, refactoring, debugging, etc.) for the custom DSLs. Because MPS stores code in AST form, features like refactoring or real-time error checking are implemented uniformly for any DSL defined in the system. The environment also supports building **rich tooling** around DSLs – for example, interpreters, simulators, debuggers, or documentation generators can be built as part of the language definitions.

By combining these features, MPS allows developers to create tailor-made languages with the same level of tooling support that one would expect for a general-purpose language. The crucial difference from traditional programming environments is that in MPS the syntax is not fixed to a text grammar; instead, the _language engineer_ defines how the code is represented and edited. This **language-oriented programming** philosophy gives end-users of the DSLs “unprecedented freedom” to express domain concepts directly, compared to writing in a generic programming language.

## History and Development

JetBrains MPS was born from a vision to change how we create software by raising the level of abstraction in programming. In the early 2000s, JetBrains (known for the IntelliJ IDEA IDE) was experimenting with a new web application development tool, code-named “Fabrique.” The experience of building Fabrique convinced the team that a more flexible platform was needed to define custom languages for such tools, which led them to start developing MPS.

JetBrains CEO Sergey Dmitriev formally articulated this vision in 2003–2004 as “Language Oriented Programming” – the idea of creating a toolkit to build languages adapted to specific domains. MPS was the practical implementation of that idea, aiming to let developers extend programming languages or design new DSLs with full tooling support.

**Key milestones in MPS’s development:**

-   **2003** – **Concept inception**: Dmitriev conceives the MPS project around 2003 as a solution for easier language creation and starts an early prototype. Martin Fowler identified JetBrains MPS (alongside a few others like Intentional Software) as part of a new class of “language workbenches” making language-oriented development a viable approach.
-   **2005** – **Early Access**: JetBrains publicly discusses MPS and plans an Early Access Program (EAP). By mid-2005, JetBrains hoped to have a usable preview available, reflecting their open development approach. (In practice, MPS took a few more years of R&D before a public beta.)
-   **2007–2008** – **First public beta**: After extensive internal development, MPS was opened to external users in beta form. In late 2008, JetBrains announced a beta release of MPS and described its core concepts (projectional AST editing, etc.). This period gathered user feedback and refined the tool.
-   **2009** – **Version 1.0 release**: MPS 1.0 was officially released in July 2009. JetBrains declared it a “new conceptual software development environment” implementing the LOP paradigm. At launch, MPS was free to use, and a large portion of its source code was made available under the Apache 2.0 open-source license. This openness encouraged community involvement. Notably, the **first commercial product built with MPS**, JetBrains’ own issue tracker **YouTrack**, was released in late 2009, demonstrating MPS’s capabilities on a real-world application.
-   **2010** – **Open sourcing**: By 2010, JetBrains moved the entire MPS codebase to a public repository. Just before the 1.5 update, the team announced that the MPS source code repository was now publicly accessible and open for contributions. This solidified MPS as a true open-source project and allowed external developers to collaborate.
-   **2011** – **MPS 2.0**: The 2.0 release marked MPS’s graduation to a more mature platform with significant new features. It introduced support for creating **standalone DSL-based IDEs** – meaning you could package a custom language with its editor into an independent application. Other improvements included a new system for tracing type computations, enhanced merging and version control for the AST-based code, built-in data-flow analysis language, and support for tabular editors. These updates reflected lessons learned and made MPS more usable for larger projects.
-   **2010s (mid-decade)** – **Growth and stabilization**: Over the next years, JetBrains regularly updated MPS (versions 3.0, 3.1, etc., through annual releases). The focus was on performance, usability, richer notations, and integration. The core architecture (projectional editing and language workbench capabilities) remained, but the tool became more robust and user-friendly, guided by community feedback and real-world use cases. In 2013–2014, for instance, a comprehensive two-volume book _“The MPS Language Workbench”_ by Fabien Campagne was published, indicating the growing maturity and user base of MPS.
-   **2020s** – **Current status**: MPS continues to be actively developed and maintained by JetBrains with a dedicated team (on the order of 10 full-time developers) and community contributors. Regular releases keep the platform up to date. For example, version **2022.2** (released in late 2022) is noted as a stable release, and new features are still being added as of 2024–2025. Throughout its evolution, the fundamental concept of projectional, language-oriented editing has remained the cornerstone of MPS.

Over its development history, JetBrains MPS transitioned from a research concept to a production-ready platform. Its open-source nature and continuous improvement have made it one of the leading tools for DSL development. Each major update not only added features but also validated the approach of MPS, showing that languages created with it could tackle real software problems (from web applications to embedded systems). JetBrains’ commitment (evidenced by ongoing releases and support) underscores that MPS has moved from an experimental idea to a significant piece of the software development landscape.

## Significance and Impact on Software Development

JetBrains MPS’s introduction was significant because it proposed a shift in how developers approach building software: _write your own language for the problem, rather than shoehorn the problem into an existing language_. This embodies the **Language-Oriented Programming (LOP)** paradigm that Dmitriev championed. 

MPS demonstrated that with proper tooling support, creating a custom DSL is a viable way to improve productivity and expressiveness for certain domains. By providing an out-of-the-box environment for language engineering, MPS lowered the barrier to implementing DSLs compared to previous ad-hoc or academic tools. Martin Fowler cited MPS as a prime example of the emerging “language workbenches” he predicted would be _“the killer app for DSLs”_, as it uses modern IDE technology to make LOP practical. In effect, MPS has helped popularize the idea that tailor-made languages can be realistic in mainstream software development, not just in research.

One of MPS’s key impacts is on how **ambiguity and language composition** are handled. Traditional text-based DSLs often struggle with composing multiple languages together due to grammar conflicts; MPS showed a way to overcome this by abandoning text parsing. 

This has influenced language design thinking: developers can now safely build complex systems with several integrated DSLs (each focused on a facet of the system) without worrying that they will interfere with each other syntactically. For software language engineering, this was a notable breakthrough — MPS provided a concrete solution to the long-standing problem of **grammar composition** in DSLs. It proved that projectional editing could achieve what parser-based frameworks could not, enabling truly **modular language extensions** and embeddable DSLs.

MPS also had an impact on **model-driven development (MDD)** practices. In many ways, an MPS language is a high-level model of a domain, which is then automatically transformed into executable code. This aligns with the goals of MDD: raising the abstraction level and generating lower-level artifacts. MPS made it possible to develop complex domain models with the convenience of a multi-notation (text, diagrams, tables, math, etc.) IDE and then generate reliable code from them. 

Compared to traditional modeling tools (like UML or EMF-based graphical model editors), MPS offers a more programmer-friendly approach — models are edited in a form that resembles code (with keyboard editing, modular structure, etc.) but still carry the full semantic rigor of a model behind the scenes. This combination has bridged the gap between modeling and programming: developers and domain experts can collaborate using DSLs that feel more like writing code and documents seamlessly together in one view, and the platform ensures those high-level specifications are consistently compiled down to working software. For instance, domain experts in finance or law can use an MPS-based DSL to encode rules or regulations, and developers can integrate this DSL into the software system, with MPS handling the code generation. This capability has been highlighted in projects like a DSL for tax law calculations, where legal rules are encoded in a form accessible to tax specialists and then automatically translated into executable code.

Another aspect of MPS’s significance is its influence on the **community and education** around language design. Because MPS is open source and free, it became a accessible platform for experimentation. Researchers in language engineering have used MPS to prototype new ideas (for example, projectional editors for product lines, or combining formal verification with programming) and then reported on these experiences in academic papers. 

The existence of MPS as a stable, industry-backed tool has arguably helped legitimize DSL and language workbench concepts in the eyes of practitioners. Where previously creating a DSL might have seemed too costly or esoteric, MPS provided a concrete example that it can be done systematically. The tool has also been integrated into **academic curricula** for software language engineering, allowing students to learn and apply DSL design using a professional-grade environment. Over the past decade, multiple books (e.g., _The MPS Language Workbench_ (2014) and _Domain-Specific Languages in Practice with JetBrains MPS_ (2021)) and numerous papers have been published, reflecting and reinforcing MPS’s role in advancing the state of the art.

In summary, JetBrains MPS’s impact lies in proving that **language engineering can improve real-world software development**. It has shown that domain-specific languages, supported by proper tooling, can make developers more productive and allow domain experts to participate directly in the software development process. 

By enabling the creation of robust DSLs, MPS has influenced both how companies develop certain classes of software (preferring a DSL solution when appropriate) and how researchers approach language design problems (using MPS as a platform to implement and evaluate new language concepts). It stands as a practical realization of language-oriented software development, influencing tools and projects that came after it.

## Adoption in Industry and Academia

Since its release, JetBrains MPS has seen steady adoption across a variety of industries and has a vibrant user community. JetBrains reports that **MPS is a mature product used in domains including electrical engineering, insurance, tax legislation, healthcare, and others**. 

The flexibility to create custom languages has attracted companies who need to handle complex domain logic or product configurations in a maintainable way. Notably, several large technology companies have adopted MPS to implement DSLs for their specific needs – _“companies such as Siemens, Bosch, Canon, and others are using MPS to implement powerful DSLs for their respective domains”_. These are engineering-driven organizations, and their use of MPS indicates confidence that DSL solutions can yield productivity or quality benefits in practice (for example, in automotive software or hardware design processes).

Some **notable projects and use cases** of JetBrains MPS include:

-   **JetBrains YouTrack** – In 2009 JetBrains released _YouTrack_, a commercial bug and issue tracking system, as the first product developed entirely using MPS.

    The YouTrack team created a suite of DSLs for web development (codenamed “Charisma”) on top of MPS, effectively using MPS as a high-level platform instead of a traditional programming stack. The success of YouTrack demonstrated MPS’s capability to deliver a full-fledged, enterprise-grade application and validated the approach of developing software via DSLs. YouTrack’s example showed other companies that it was possible to build complex web applications by designing custom languages for business logic, UI, etc., and then generating the final application code.
-   **mbeddr (Embedded C Language Extensions)** – _mbeddr_ is an open-source integrated development environment for embedded software, developed by itemis AG (a Germany-based consultancy) on top of MPS.
      
    Introduced around 2012, mbeddr uses MPS to extend the C language with domain-specific extensions and formal verification features for embedded systems programming. It provides DSLs for components, state machines, physical units, and other embedded concepts, all seamlessly mixed with standard C code. Because mbeddr is built with MPS, users can even create new extensions to C or add their own DSLs for their project needs. The project’s success in industry (supported by itemis and partially funded by research grants) has been a showcase for MPS in the embedded systems domain. It proved that even performance-critical, low-level software (like firmware) can benefit from DSLs to increase safety and developer efficiency (e.g., by catching domain errors early and enabling model checking). JetBrains and itemis collaborated on this project, and JetBrains adjusted MPS’s development to support mbeddr’s requirements, illustrating a fruitful industry partnership. mbeddr’s use of MPS has been reported in numerous case studies and won recognition in the modeling community as a pioneering use of DSLs in embedded development.
-   **Domain-Specific Business Languages** – MPS is used to create DSLs in domains like insurance and finance, where business logic is complex and subject to change. For example, researchers and engineers have developed an MPS-based DSL for tax rules at a tax administration, encoding legislation (such as an Anti-Tax Avoidance Directive) into an executable form.
    
    Similarly, a large European payroll company (DATEV) worked with language engineers to create a DSL for payroll calculations using MPS, allowing tax and pension experts to write rules that are then generated into software. Many more applications exist in various fields, such as medical support applications, (medical) high-tech equipment development, automotive development, production printing development, and advanced commercial modeling tooling. These projects allow domain specialists (who are not traditional programmers) to contribute directly by writing specifications in a controlled natural language or DSL, with MPS ensuring those specs are consistent and generating the necessary code. Such use cases highlight MPS’s value in **knowledge-intensive domains**: it can capture regulatory or expert knowledge in a formal language that is easier to maintain than thousands of lines of general-purpose code. Companies have reported that using MPS DSLs in these areas improves communication with domain experts and reduces bugs in the critical business logic.
-   **Academic and Research Projects** – The academic community quickly recognized MPS as a useful platform for experimenting with language design. Numerous projects in software language engineering have been built with MPS. For instance, **PEoPL (Projectional Editing of Product Lines)** is a research tool implementing software product line variability using MPS’s projectional editor.
    
    Another example is the **Gamification Design Framework (GDF)**, which provides DSLs for designing gamified applications; GDF was built with MPS to allow mixing of textual and graphical notations and to leverage MPS’s generation of executable code from high-level game design models. These and other projects (in fields like data analysis, educational software, etc.) have been reported in academic publications. Over the past decade, MPS has been the subject of many **research papers, theses, and books**. University courses on DSLs often incorporate MPS as a teaching tool, and every year, the MPS community (including JetBrains and external researchers) holds meetups or workshops to share experience between industry and academia. This cross-pollination has helped evolve MPS and spread knowledge of best practices in language engineering. As JetBrains notes, the community around MPS is “vibrant,” and the collaboration between academic research and real-world usage continues to refine what MPS can do.

Overall, the adoption of JetBrains MPS is **broad and growing**, but it tends to be concentrated in scenarios where the complexity of the domain warrants a custom language solution. Its use by high-profile companies like Siemens and Bosch for engineering DSLs, by software vendors like JetBrains for their own products, and by governmental or financial institutions for rule processing, all attest to its versatility.

At the same time, active academic involvement and publications ensure that MPS remains at the cutting edge of language workbench technology. This dual adoption (industry and academia) has created a feedback loop that drives improvements in MPS and demonstrates the real-world value of language-oriented development.

## Significance Revisited and Conclusion

In conclusion, JetBrains MPS represents a significant advancement in software development methodology by providing a practical, integrated environment for **creating and using domain-specific languages**. Technically, it pioneered the use of projectional editing in mainstream programming, setting it apart from traditional IDEs and inspiring a rethinking of how we represent code.

Historically, it emerged from JetBrains’ innovative culture and has since matured through open-source collaboration into a robust platform with regular releases. The tool’s impact is evident in both the products built with it and the way it has shaped discourse in language engineering and model-driven development.

JetBrains MPS has proven that **extensible languages and DSLs** are not just academic toys but can improve real software projects – from enabling domain experts to contribute in their own terms, to reducing errors by working at a higher level of abstraction.

Its adoption by industry leaders and its presence in academic research reflect a confluence of practice and theory, underlining its importance. As of today, MPS continues to **“paint the future of software development”** in the spirit envisioned by its creators, empowering teams to evolve the languages they use and bringing the promise of language-oriented programming to fruition.


